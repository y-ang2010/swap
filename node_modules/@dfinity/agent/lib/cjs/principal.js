"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Principal = void 0;
const buffer_1 = require("buffer/");
const types_1 = require("./types");
const base32_1 = require("./utils/base32");
const getCrc_1 = require("./utils/getCrc");
const sha224_1 = require("./utils/sha224");
const SELF_AUTHENTICATING_SUFFIX = 2;
const ANONYMOUS_SUFFIX = 4;
class Principal {
    constructor(_blob) {
        this._blob = _blob;
        this._isPrincipal = true;
    }
    static anonymous() {
        return new this(types_1.blobFromUint8Array(new Uint8Array([ANONYMOUS_SUFFIX])));
    }
    static selfAuthenticating(publicKey) {
        const sha = sha224_1.sha224(publicKey);
        return new this(types_1.blobFromUint8Array(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX])));
    }
    static from(other) {
        if (typeof other === 'string') {
            return Principal.fromText(other);
        }
        else if (typeof other === 'object'
            && other !== null
            && other._isPrincipal === true) {
            return new Principal(other._blob);
        }
        throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
    }
    static fromHex(hex) {
        return new this(types_1.blobFromHex(hex));
    }
    static fromText(text) {
        const canisterIdNoDash = text.toLowerCase().replace(/-/g, '');
        let arr = base32_1.decode(canisterIdNoDash);
        arr = arr.slice(4, arr.length);
        const principal = new this(types_1.blobFromUint8Array(arr));
        if (principal.toText() !== text) {
            throw new Error(`Principal "${principal.toText()}" does not have a valid checksum.`);
        }
        return principal;
    }
    static fromBlob(blob) {
        return new this(blob);
    }
    isAnonymous() {
        return this._blob.byteLength === 1 && this._blob[0] === ANONYMOUS_SUFFIX;
    }
    toBlob() {
        return this._blob;
    }
    toHash() {
        return this._blob;
    }
    toHex() {
        return types_1.blobToHex(this._blob).toUpperCase();
    }
    toText() {
        const checksumArrayBuf = new ArrayBuffer(4);
        const view = new DataView(checksumArrayBuf);
        view.setUint32(0, getCrc_1.getCrc32(this.toBlob()), false);
        const checksum = Uint8Array.from(buffer_1.Buffer.from(checksumArrayBuf));
        const bytes = Uint8Array.from(this._blob);
        const array = new Uint8Array([...checksum, ...bytes]);
        const result = base32_1.encode(array);
        const matches = result.match(/.{1,5}/g);
        if (!matches) {
            // This should only happen if there's no character, which is unreachable.
            throw new Error();
        }
        return matches.join('-');
    }
    toString() {
        return this.toText();
    }
}
exports.Principal = Principal;
//# sourceMappingURL=principal.js.map