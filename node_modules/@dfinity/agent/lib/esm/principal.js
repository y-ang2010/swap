import { Buffer } from 'buffer/';
import { blobFromHex, blobFromUint8Array, blobToHex } from './types';
import { decode, encode } from './utils/base32';
import { getCrc32 } from './utils/getCrc';
import { sha224 } from './utils/sha224';
const SELF_AUTHENTICATING_SUFFIX = 2;
const ANONYMOUS_SUFFIX = 4;
export class Principal {
    constructor(_blob) {
        this._blob = _blob;
        this._isPrincipal = true;
    }
    static anonymous() {
        return new this(blobFromUint8Array(new Uint8Array([ANONYMOUS_SUFFIX])));
    }
    static selfAuthenticating(publicKey) {
        const sha = sha224(publicKey);
        return new this(blobFromUint8Array(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX])));
    }
    static from(other) {
        if (typeof other === 'string') {
            return Principal.fromText(other);
        }
        else if (typeof other === 'object'
            && other !== null
            && other._isPrincipal === true) {
            return new Principal(other._blob);
        }
        throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
    }
    static fromHex(hex) {
        return new this(blobFromHex(hex));
    }
    static fromText(text) {
        const canisterIdNoDash = text.toLowerCase().replace(/-/g, '');
        let arr = decode(canisterIdNoDash);
        arr = arr.slice(4, arr.length);
        const principal = new this(blobFromUint8Array(arr));
        if (principal.toText() !== text) {
            throw new Error(`Principal "${principal.toText()}" does not have a valid checksum.`);
        }
        return principal;
    }
    static fromBlob(blob) {
        return new this(blob);
    }
    isAnonymous() {
        return this._blob.byteLength === 1 && this._blob[0] === ANONYMOUS_SUFFIX;
    }
    toBlob() {
        return this._blob;
    }
    toHash() {
        return this._blob;
    }
    toHex() {
        return blobToHex(this._blob).toUpperCase();
    }
    toText() {
        const checksumArrayBuf = new ArrayBuffer(4);
        const view = new DataView(checksumArrayBuf);
        view.setUint32(0, getCrc32(this.toBlob()), false);
        const checksum = Uint8Array.from(Buffer.from(checksumArrayBuf));
        const bytes = Uint8Array.from(this._blob);
        const array = new Uint8Array([...checksum, ...bytes]);
        const result = encode(array);
        const matches = result.match(/.{1,5}/g);
        if (!matches) {
            // This should only happen if there's no character, which is unreachable.
            throw new Error();
        }
        return matches.join('-');
    }
    toString() {
        return this.toText();
    }
}
//# sourceMappingURL=principal.js.map